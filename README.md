## OpenGL Realtime Ray Tracing Lab Report
### My Objective
I first heard about ray tracing in a game trailer, which shows the different effects between the rasterization and ray tracing. It seemed to be a very advanced technology and I thought it was too early for me to learn about it. When I saw this course, I immediately have the desire to take it. I also want to make ray tracing real-time as I'm more interested in games than movies. That's why I decide to work on this project.
In my project, I wish to have a scene that contains a number of objects, each having different material. I can click and drag my mouse to rotate the camera around the objects, looking at the scene from different angles.

### My Progress
###### make a runnable program
I was thinking about using BVH tree to accelerate ray tracing. I also wanted to have a hirachical scene. But these ideas slowed me down. At the same time, I was not quite sure if using OpenGL to ray trace really works. So I decided to start from a very simple program. There is no scene and no tree. I only import one model using Assimp, an open asset import library. The model will have a material. The whole scene has only one light source. Everything is simple, so it didn't take me a long time to make it runnable. There are diffuse and specular reflection, without shadow test. I am really happy to see the result. This builds up my confidence in my project. I think I can do something cool from this.

###### add more details
There is no shadow in my scene, so it's time to add a shadow test. When an eye ray hits a surface, a shadow ray comes out and points to a light source. If the shadow ray is blocked by an object, it creates a shadow. Now I have shadow. I notice that the surface is not smooth. I have done the interpolation of normals of each vertices in a triangle, but there is no use. Professor gave me a piece of advice that I could make the object set to smooth shading in Blender. It really works. The model has flat shading at first because Blender sets model to flat shading by default. Now the objects look smooth and cast shadows on other objects, but what if I want to have more objects. And I hope they have different materials so that they look more interesting.

###### scene
To create a colorful world, I need a scene, which contains objects with different materials. In a scene, I can also give an object position, rotation and scale attributes to allow me to put them anywhere. However, this also brings new problems that I need to solve. In the previous version, there is only one object in the scene, which means the object space is exactly world space or global space. Now I have more objects, so I have to do transformations. In the class, we discussed about 3D transformations. I can send tranform data of an object to shader and the shader will compute the transform matrix and apply it to all vertexes of an object. We also talked about hirachical scene, which is more complicated than my current scene. In that case, I have to use stack to get the transform matrix of each object. My scene is just a list of objects and lights, so I don't have to do that. 
Now I can run my program. In my example, there are two toruses in different colors(one is orange, the other is white). I put them in different positions and rotations so they look chained together. That's really more interesting than previos versions! But it doesn't run very smoothly, which I will solve later.

###### accelerating structure --BVH tree
Since I am developing a realtime program, I need to generate a single image in less than 20 milliseconds. Traversing all triangles to see if they intersect the rays is too expensive, failing to produce smooth realtime experience. That's why I decide to use BVH tree. We discussed about BSP tree in class, but I think it's more difficult to implement. BVH tree uses Axis-Aligned Bounding Box to surround objects. If the box is not hit, the objects inside will certainly intersect with rays. In my program, for each object, I put triangles into its BVH tree, which is stored in an array. When I want to know which triangle a ray hit, I traverse each object and call a hitBVH function on that object. In this function, triangles inside boxes that miss the ray will not be visited, which saves a lot time. Now I gain great efficiency improvment. I can also use a tree to organize the whole scene, but that's not necessary because I don't need a lot of objects in the scene right now.

###### supersampling
The extra time given by using BVH tree allows me to do more computation and improve the quality. We discussed about aliasing in class and several ways to overcome the problem. I used "distributed" raytracing, which means I send multiple rays (jittered) for a single pixel and average the results together. 

###### no recursive fucntion in glsl...
Reflection and refraction in raytracing rely on recursive functions. I remembered professor mentioned non-recursive raytracing but I actually don't have enough time to study it. Unfortunately, I can't have recursive calls in GLSL, so I think it is very diffcult, if not impossible, to implement reflection and refraction in my program. That's a pity because reflection and refraction makes the scene look beautiful and complex. But I finished the assignment and completed the reflection and refraction part.
